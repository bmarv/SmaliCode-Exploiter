import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class ParseManifest {
	//for Meta-Data
	public String packageName;
	public String classes[];
	public List<String> permissions = new ArrayList<String>();
	public int androidVersionCode;
	public String androidVersionName;
	public int minSdkVersion;
	public int compileSdkVersion;
	public HashMap<String, Intents> Activities = new HashMap<String, Intents>();
	public HashMap<String, Intents> Broadcast = new HashMap<String, Intents>();
	public List<String> activitiesOnly = new ArrayList<String>();
	public List<String> libraries = new ArrayList<String>();
	public List<String> broadcastsOnly = new ArrayList<String>();
	public Path pathToSmali;
	
	//Constructor
	public ParseManifest(String Input) {
		//delete all whitespaces in case of newlines etc.
		Input=Input.replaceAll("[\\n\\s]", "");
		this.packageName = getPackage(Input);
		this.permissions = getPermissions(Input);
		this.androidVersionCode= getAndroidVersionCode(Input);
		this.androidVersionName = getAndroidVersionName(Input);
		this.minSdkVersion = getMinSdkVersion(Input);
		this.compileSdkVersion = getCompileSdkVersion(Input);
		this.Activities= setActivities(Input);
		this.Broadcast= setBroadcasts(Input);
		this.activitiesOnly=getActivities(setActivities(Input));
		this.libraries = getLibraries(Input);
		this.broadcastsOnly=getBroadcasts(setBroadcasts(Input));
	}
	
	//Methods
	
	/**
	 * returns String with location of the package
	 * @param Input
	 * @return location of the package
	 */
	public String getPackage(String Input) {
		String packageName = null;
		Pattern packagePattern = Pattern.compile("(?<=package=\")(.)*?(?=\")");
		Matcher packageMatcher = packagePattern.matcher(Input);
		if(packageMatcher.find()) {
			packageName = packageMatcher.group();
		}
		return packageName;
	}
	
	
	/**
	 * parses Permissions from Manifest and outputs it as a String-ArrayList
	 * @param Input
	 * @return String-ArrayList
	 */
	public List<String> getPermissions(String Input) {
		List<String> perm=new ArrayList<String>();
		Pattern permPattern = Pattern.compile("(?<=<uses-permissionandroid:name=\"android.permission.)(.)*?(?=\")");
		Matcher permMatcher = permPattern.matcher(Input);
		
		while(permMatcher.find()) {
			perm.add(permMatcher.group());
		}
		return perm;
	}
	
	/**
	 * returns an Integer with the VersionCode
	 * @param Input
	 * @return
	 */
	public int getAndroidVersionCode(String Input) {
		int versionCode=-1;
		Pattern codePattern = Pattern.compile("(?<=android:versionCode=\")(.)*?(?=\")");
		Matcher codeMatcher = codePattern.matcher(Input);
		if(codeMatcher.find())
			versionCode=Integer.valueOf(codeMatcher.group());
		return versionCode;
	}
	
	
	/**
	 * returns String with Version-Name
	 * @param Input
	 * @return
	 */
	public String getAndroidVersionName(String Input) {
		String name= null;
		Pattern namePattern = Pattern.compile("(?<=android:versionName=\")(.)*?(?=\")");
		Matcher nameMatcher = namePattern.matcher(Input);
		if(nameMatcher.find())
			name=nameMatcher.group();
		
		return name;
	}
	
	
	/**
	 * returns the earliest release of android sdk, this application can run
	 * @param Input
	 * @return
	 */
	public int getMinSdkVersion(String Input) {
		int minSdk=-1;
		Pattern sdkPattern = Pattern.compile("(?<=android:minSdkVersion=\")(.)*?(?=\")");
		Matcher sdkMatcher = sdkPattern.matcher(Input);
		if(sdkMatcher.find())
			minSdk=Integer.valueOf(sdkMatcher.group());
		return minSdk;
	}
	
	/**
	 * returns the version of the apk file, when it was compiled by the IDE
	 * @param Input
	 * @return
	 */
	public int getCompileSdkVersion(String Input) {
		int compSdk= -1;
		Pattern compPattern =Pattern.compile("(?<=android:compileSdkVersion=\")(.)*?(?=\")");
		Matcher compMatcher = compPattern.matcher(Input);
		if(compMatcher.find())
			compSdk=Integer.valueOf(compMatcher.group());
		return compSdk;
	}
	
	/**
	 * returns a HashMap including the Name of the Activity and the Path to the Activity
	 * @param Input
	 * @return
	 */
	public HashMap<String, Intents> setActivities(String Input){
		
		HashMap<String, Intents> Activity = new HashMap<String, Intents>();
		
		//get each Activity
		List<String> fullActivityArr= new ArrayList<String>();
		Pattern fullActivity = Pattern.compile("<activity(.)*?(</activity>)");
		Matcher fullActivityMatcher = fullActivity.matcher(Input);
		
		while(fullActivityMatcher.find()) {
			fullActivityArr.add(fullActivityMatcher.group());
		}
		
		//get basic Activity-Info for each Activity
		for(String a: fullActivityArr) {
			Intents ActivityIntent = new Intents();
			
			String activityName=null;
			Pattern activityPattern = Pattern.compile("(?<=<activityandroid:name=\")(.)*?(?=\")");
			Matcher activityMatcher = activityPattern.matcher(a);
			
			if(activityMatcher.find()) {
				activityName=activityMatcher.group();
			}
			//get Intents from the needed part
			List<String> action= new ArrayList<String>();
			Pattern actionPattern = Pattern.compile("(?<=<actionandroid:name=\")(.)*?(?=\")");
			Matcher actionMatcher = actionPattern.matcher(a);
			while(actionMatcher.find())
				action.add(actionMatcher.group());
			ActivityIntent.setAction(action);
			
			List<String> category= new ArrayList<String>();
			Pattern categoryPattern = Pattern.compile("(?<=<categoryandroid:name=\")(.)*?(?=\")");
			Matcher categoryMatcher = categoryPattern.matcher(a);
			while(categoryMatcher.find())
				category.add(categoryMatcher.group());
			ActivityIntent.setCategory(category);
			
			List<String> data = new ArrayList<String>();
			Pattern dataPattern = Pattern.compile("(?<=<dataandroid:mimeType=\")(.)*?(?=\")");
			Matcher dataMatcher = dataPattern.matcher(a);
			while(dataMatcher.find())
				data.add(dataMatcher.group());
			ActivityIntent.setData(data);
			
			Activity.put(activityName, ActivityIntent);
		}
		
		return Activity;
	}
	
	public List<String> getActivities(HashMap<String, Intents> Activities) {
		List<String> activitiesOnly = new ArrayList<String>();
		
		for(String s: Activities.keySet()) {
			activitiesOnly.add(s);
		}
		return activitiesOnly;
	}
	
	
	public List<String> getLibraries(String Input){
		List<String> libraries= new ArrayList<String>();
		
		Pattern librariesPattern = Pattern.compile("(?<=<uses-libraryandroid:name=\")(.)*?(?=\")");
		Matcher librariesMatcher = librariesPattern.matcher(Input);
		
		while(librariesMatcher.find())
			libraries.add(librariesMatcher.group());
		
		return libraries;
	}
	
	
	public HashMap<String, Intents> setBroadcasts(String Input){
		HashMap<String, Intents> Broadcast = new HashMap<String, Intents>();
		
		//get each Broadcast
		List<String> fullBroadcastArr= new ArrayList<String>();
		Pattern fullBroadcast = Pattern.compile("<receiver(.)*?(</receiver>)");
		Matcher fullBroadcastMatcher = fullBroadcast.matcher(Input);
		
		while(fullBroadcastMatcher.find()) {
			fullBroadcastArr.add(fullBroadcastMatcher.group());
		}
		
		//get basic Activity-Info for each Activity
		for(String a: fullBroadcastArr) {
			Intents BroadcastIntent = new Intents();
			
			String broadcastName=null;
			Pattern broadcastPattern = Pattern.compile("(?<=<receiverandroid:name=\")(.)*?(?=\")");
			Matcher broadcastMatcher = broadcastPattern.matcher(a);
			
			if(broadcastMatcher.find()) {
				broadcastName=broadcastMatcher.group();
			}
			//get Intents from the needed part
			List<String> action= new ArrayList<String>();
			Pattern actionPattern = Pattern.compile("(?<=<actionandroid:name=\")(.)*?(?=\")");
			Matcher actionMatcher = actionPattern.matcher(a);
			while(actionMatcher.find())
				action.add(actionMatcher.group());
			BroadcastIntent.setAction(action);
			
			
			Broadcast.put(broadcastName, BroadcastIntent);
		}
		return Broadcast;
	}
		
	public List<String> getBroadcasts(HashMap<String, Intents> Broadcasts) {
		List<String> broadcastsOnly = new ArrayList<String>();
		
		for(String s: Broadcasts.keySet()) {
			broadcastsOnly.add(s);
		}
		return broadcastsOnly;
	}	
	
	public Path toSmaliPackage(Path forPath) {
		String forPackage = this.packageName;
		forPackage = forPackage.replaceAll("\\.", "\\/");
		Path toSmaliData = Paths.get(forPath+"/smali_classes2/"+forPackage);
		if(!toSmaliData.toFile().exists()) {
			//try ./smali/ when ./smali_classes2/ not exists
			toSmaliData = Paths.get(forPath+"/smali/"+forPackage);
			if(!toSmaliData.toFile().exists()){
				System.out.println("this path doesn't exist");
				return null;
			}
			return toSmaliData;
		}	else {
			return toSmaliData;
		}
	}
	
	public String toString() {
		String result = "\n\n---Reading important Informations from AndroidManifest.xml - more Information is stored in ParseManifest---\n" 
				+"packageName="+this.packageName
				+ "\npermissions="+this.permissions
				+"\nActivities="+this.Activities;
		return result;
	}
	
}
